# Generated by Django 4.2.10 on 2025-04-18 17:37

import datetime
from django.db import migrations
from django.utils import timezone


def migrate_logs_to_job_logs(apps, schema_editor):
    """
    Migrate logs from Job.logs (SchemaField) to the new JobLog model.
    """
    Job = apps.get_model("jobs", "Job")
    JobLog = apps.get_model("jobs", "JobLog")

    for job in Job.objects.all():
        # Skip jobs without logs
        if not hasattr(job, "logs") or not job.logs:
            continue

        # Migrate stdout logs
        for log_msg in job.logs.stdout:
            # Parse timestamp and level from log format
            # Example format: "[2025-04-17 14:52:30] INFO Some message here"
            try:
                # Extract timestamp from between square brackets
                timestamp_str = log_msg[1:20] if log_msg.startswith("[") else None
                # Find the end of the level part (next space after timestamp)]
                level_start = log_msg.find("] ") + 2 if "] " in log_msg else 0
                level_end = log_msg.find(" ", level_start) if " " in log_msg[level_start:] else len(log_msg)

                level = log_msg[level_start:level_end].strip() if level_start < level_end else "INFO"
                message = log_msg[level_end:].strip() if level_end < len(log_msg) else log_msg

                # Convert timestamp string to datetime or use current time
                if timestamp_str and len(timestamp_str) == 19:  # YYYY-MM-DD HH:MM:SS
                    try:
                        timestamp = datetime.datetime.strptime(timestamp_str, "%Y-%m-%d %H:%M:%S")
                        timestamp = timezone.make_aware(timestamp)
                    except ValueError:
                        timestamp = timezone.now()
                else:
                    timestamp = timezone.now()

                # Create the log entry
                JobLog.objects.create(
                    job=job,
                    level=level[:20],  # Truncate to max length if needed
                    message=message,
                    timestamp=timestamp,
                    is_error=False,
                )
            except Exception as e:
                print(f"Error migrating stdout log for job {job.pk}: {e}")
                # Create a fallback entry if parsing fails
                JobLog.objects.create(job=job, level="INFO", message=log_msg, timestamp=timezone.now(), is_error=False)

        # Migrate stderr logs
        for error_msg in job.logs.stderr:
            JobLog.objects.create(job=job, level="ERROR", message=error_msg, timestamp=timezone.now(), is_error=True)


def reverse_migration(apps, schema_editor):
    """
    Since we're keeping the old logs field, no reverse migration is needed.
    We'll simply leave the JobLog entries as they are.
    """
    pass


class Migration(migrations.Migration):
    dependencies = [
        ("jobs", "0017_joblog"),
    ]

    operations = [
        migrations.RunPython(migrate_logs_to_job_logs, reverse_migration),
    ]
